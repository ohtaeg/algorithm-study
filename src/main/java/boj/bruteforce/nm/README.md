# N 과 M
- 해당 문제 유형들은 `백트래킹`을 연습하고자 하는 의도라고 한다.

## 백트래킹
- 말 그대로 되추적인데 어떤 노드의 `유망성`을 판단한 뒤, 해당 노드가 유망하지 않다면 부모 노드로 돌아가 다른 자식 노드를 찾는 방법이다. 
- 즉, 모든 경우의 수를 찾아보지만, 그 중에서도 가능성만 있는 경우의 수만 찾아보는 방법이다. 
- 현재 상태에서 가능한 모드 후보군을 따라 들어가며 탐색하는 알고리즘
- 알고리즘 문제를 해결하기 위해 보통 재귀를 이용하며 DFS를 이용한다.

## 재귀
- 하나의 함수에서 자기 자신을 다시 호출해 작업을 수행하는 알고리즘
- 어떤 문제를 재귀로 푼다는 것은 곧 귀납적인 방식으로 푼다는 것인데 귀납적인 방식이라는것은 우리의 상식과 큰 차이가 있다.
- 우리가 당연하게 생각하던 절차지향적인 사고를 탈피해야 한다.
- 2가지의 예를 들어보자.
1. 도미노
- 도미노를 예로 들어 맨 앞의 도미느롤 쓰러트리개 되면 모든 도미노가 쓰러질텐데, 왜 모든 도미노가 쓰러지는지를 설명해보라고 한다면 2가지 방식으로 설명한다.
    1. 1번 도미노가 쓰러지면 2번 도미노가 쓰러지고, 2번 도미노가 쓰러지면 3번 도미노가 쓰러진다.
    2. 수학적 귀납법을 이용한 방법으로, k번 도미노가 쓰러지면 k+1번 도미노가 쓰러진다라는 명제가 참이되어 모든 도미노가 쓰러진다.
    - 2개의 방법은 똑같이 느껴지지만 우리는 k번 도미노가 쓰러지면 k+1번 도미노가 쓰러진다는 결론에 도달할 수 있어야 한다.
2. n 부터 1 까지 출력하는 문제를 절차지향적 사고와 귀납적 사고의 차이를 알아보자.
```
void func(int n) {
    if (n == 0) {
        return;
    }
    print(n);
    func(n - 1);
}
```
- 절차지향적인 사고로 func1(3)의 출력 결과가 왜 3 2 1인지를 생각해본다면
    - func1(3)가 호출되면 3을 출력하고 func1(2)를 호출한다.
    - func1(2)는 2를 출력한 후에 func1(1)을 호출할거고 func1(1)은 1을 출력한 후에 func1(0)을 호출한다.
    - 그리고 func1(0)은 02번 줄에 걸려서 종료된다.
    - 이렇게 과정을 따라가고 나면 func1(3)을 실행했을 때 3 2 1이 출력된다는 것을 알 수 있다.
    ```
       3 출력
          |
       func(2) 호출
          |
       2 출력
          |
       func(1) 호출
          |
       1 출력
          |
       func(0) 호출
          |
       종료
    ```
- 귀납적인 사고로 func1(3)의 출력 결과가 왜 3 2 1인지를 생각해본다면
    - func(1)이 1을 출력한다.
    - func(k)가 k를 출력하면 func(k - 1)는 k-1을 출력하여 즉 k부터 1까지 차례대로 호출하면 func(k - 1)은 k - 1부터 1까지 차례로 출력한다.
- 1부터 n 까지의 합을 구하는 함수에 대해서도 왜 올바른 결과를 내는지 과정을 하나하나 따라가는 대신 귀납적인 사고를 통해서 이해해보려고 노력해보자.

## 재귀 사용시 주의할점
1. 함수를 명확하게 정의해야한다. 정의라는건 함수의 인자로 어떤 것을 받을지, 그리고 어디까지 계산한 후 자기 자신에게 넘겨줄지를 의미한다.
2. 모든 재귀 함수는 반복문만으로 동일한 동작을 하는 함수로 변경할 수 있다.
3. 재귀는 반복문 구현에 비해 코드가 간결하지만 메모리/시간에서는 손해를 본다.
    - 구현하면서 코드의 복잡도가 높아지면 재귀로 구현하는것이 좋다.
4. 재귀가 자기 자신을 여러번 호출하게 되면 비효율적일 수 있다.
    - ex) 피보나치 수열
    - 이미 계산한 값을 또 중복 호출하게 되어 시간 복잡도는 지수만큼 증가한다.
5. 재귀 함수가 자기 자신을 부를때 스택 영역에 계속 쌓이기 때문에 스택 메모리가 제한된 곳에서 문제를 풀고 있을때 재귀가 깊어지면 재귀 대신 반복문으로 풀어야 한다.
    - 지역 변수도 스택 메모리에 들어가는것을 잊지말자.

### 재귀 연습문제
1. [백준 1629](https://www.acmicpc.net/problem/1629) 곱셈 문제, a<sup>b</sup>를 m으로 나눈 나머지, 즉 a<sup>b</sup> mod m을 구해야할 때 어떻게 구할 수 있을까? (라이브러리 이용 없이)
- 절차적으로 구현한다면 다음과 같을 것이다.
```
int pow(int a, int b, int m) {
    int number = 1;
    while (b-- > 0) {
        number *= a;
    }
    return number % m;
}
```
- 위 코드는 문제가 있다 만약 a = 6, b = 100을 넘겨준다면 6<sup>100</sup>의 결과값은 int overflow로 인해 number가 0이 되어 올바르게 구할 수 없다.
- 뿐더러 최대 21억이하의 자연수들이 주어지기 때문에 a를 b번 곱하는 방식은 시간초과가 발생하게 된다. 어떻게 해야할까?
- 귀납적으로 생각해보자.
    - a<sup>n</sup> * a<sup>n</sup> = a<sup>2n</sup>
    - 12<sup>58</sup> ≡ 4(mod 67)
    - 12<sup>116</sup> ≡ 16(mod 67)
    - 1번 도미노가 쓰러진다.
    - k번 도미노가 쓰러지면 k + 1번 도미노도 쓰러진다.
    - 1승을 계산할 수 있다. 1승 계산시 시간복잡도는 O(1)이 걸렸다.
    - k승을 계산했으면 2k승과 2k + 1승도 계산할 수 있다. 2k승과 2k + 1승도 O(1)에 계산할 수 있다.
    - 그러고 나서 곱하는 중간 마다 계속 m으로 나눠서 나머지만 챙겨간다.
        - 왜 ? 예로 37 * 38 mod 36의 나머지는 어떻게 구할 수 있을까?
            - (36 + 1) * (36 + 2) mod 36
            - 1 * 2 = 2
    ```
    static long pow2(int a, int b, int m) {
        if (b == 0) {
            return a % m;
        }

        long number = pow2(a, b / 2, m);
        number = number * number % m;
        
        if (number % 2 == 0) {
            return number;
        }
        return number * a % m;
    }
    ```
  - 추가로 더 정리하자 https://www.youtube.com/watch?v=8vDDJm5EewM&ab_channel=BaaarkingDog
  - https://blog.encrypted.gg/943
  - https://www.youtube.com/watch?v=na83boTKOgs&ab_channel=%EC%B0%A8%EA%B8%B8%EC%98%81%EC%9D%98%EC%84%B8%EB%B8%90%EC%97%90%EB%93%80
    


    
    
    

