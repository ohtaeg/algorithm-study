# 그래프
- 기본 구조는 노드와 간선으로 표현되며 그래프 탐색이란 하나의 노드를 시작으로 다수의 노드를 방문하는것을 말한다.
  - G(V, E)
  - Graph(Vertex, Edge)
- 그래프는 2가지 방법으로 표현할 수 있다.
  - 인접 행렬 : `2차원 배열`로 그래프의 연결 관계를 표현
    - 노드가 연결된 형태를 기록한다.
    - 연결되지 않은 노드들끼리는 무한의 비용이 든다하여, 주로 무한으로 표현한다.
    - 무한은 논리적인 정답이 될 수 없기에 999999999와 같은 값으로 초기화한다.
  - 인접 리스트 : `링크드 리스트`로 그래프의 연결 관계를 표현
- 그래프의 특징은 다음과 같다.

<br>

### 무방향 그래프
```
1  ㅡ   2  ㅡ  5
|      |
3  ㅡ   4

행   열
a   b => 노드 번호 (vertex)
(1, 2) 
(1, 3) 
(2, 4) 
(2, 5) 
(3, 4)
```
- 인접 행렬
```        
private static final int INFINITY = 999999999;
int[][] graph = new int[a][b];
graph[1][2] = 1;
graph[2][1] = 1;

graph[1][3] = 1;
graph[3][1] = 1;

graph[2][4] = 1;
graph[4][2] = 1;

graph[3][4] = 1;
graph[4][3] = 1;
   
graph[2][5] = 1;
graph[5][2] = 1;
로 표현할 수 있다.
```
- 인접 리스트
```
List<List<Integer>> graph = new ArrayList<>();
for (int i = 0; i <= n; i++) {
    graph.add(new ArrayList<>());
}
graph.get(1).add(2);
graph.get(2).add(1);

graph.get(1).add(3);
graph.get(3).add(1);

graph.get(2).add(4);
graph.get(4).add(2);

graph.get(3).add(4);
graph.get(4).add(3);

graph.get(2).add(5);
graph.get(5).add(2);
```

<br>

### 방향 그래프
```
1  ㅡ*   2  ㅡ*  5
|       *
*       |
3  ㅡ*   4

1 -> 2
1 -> 3
3 -> 4
4 -> 2
2 -> 5
```
- 인접 행렬
```        
private static final int INFINITY = 999999999;
int[][] graph = new int[a][b];
graph[1][2] = 1;
graph[1][3] = 1;
graph[3][4] = 1;
graph[4][2] = 1;
graph[2][5] = 1;
```
- 인접 리스트
```
List<List<Integer>> graph = new ArrayList<>();
for (int i = 0; i <= n; i++) {
    graph.add(new ArrayList<>());
}
graph.get(1).add(2);

graph.get(1).add(3);

graph.get(2).add(4);

graph.get(3).add(4);

graph.get(2).add(5);
```

<br>

### 가중치 방향 그래프
```
 1  ㅡ(2)*   2  ㅡ(5)*  5
 |          *
(4)        (2)
 *          |
 3  ㅡ(5)*   4

a    b    v
1 -> 2    2
1 -> 3    4
3 -> 4    5   
4 -> 2    2
2 -> 5    5
```
- 인접 행렬
```        
private static final int INFINITY = 999999999;
int[][] graph = new int[a][b];
graph[1][2] = 2;
graph[1][3] = 4;
graph[3][4] = 5;
graph[4][2] = 2;
graph[2][5] = 5;
```

<br>

## 인접 행렬과 인접 리스트의 차이
- `메모리 측면`에서 탐색시 `인접 행렬`은 모든 관계를 저장한 상태에서 다뤄야하므로 노드의 갯수가 많을수록 메모리의 낭비가 있다.
  - 인접 리스트는 연결된 정보만 가지고 탐색하기 때문에 모든 행열을 탐색하지 않아도 되기 때문에 **인접 리스트가 인접 행렬보다 메모리 효율이 좋다.**
  - 인접 행렬은 정점의 수가 100개까지는 괜찮지만 그 이상부터는 인접리스트가 효율적이다.
- `속도 측면`에서 인접 리스트는 연결된 데이터를 하나씩 확인해야해서 느리다.
- 그러므로 특정한 노드가 연결된 인접 노드를 순회해야하는 경우는 인접리스트 방식이 인접 행렬보다 메모리 낭비가 적다.

<br>
<br>
<br>

# DFS
- Depth First Search 약자로 `깊이 우선 탐색`이라고 한다.
  - 그래프에서 깊은 부분을 우선적으로 탐색한다는 뜻
  - `시간 복잡도는 O(N)`이 소요된다.


## DFS 동작 원리
- 특정한 경로로 탐색하다가 특정한 상황에서 최대한 깊숙히 들어가서 노드를 방문 후 다시 돌아와 다른 경로로 탐색하는 과정을 거친다.
- 한번 방문했던 노드는 다신 방문하지 않기 위해 스택을 주로 이용한다.
1. 탐색 시작 노드를 Stack에 삽입 후 방문 처리를 한다.
2. 스택 최상단의 노드기준으로 방문하지 않은 노드가 있다면 최상단 노드의 인접 노드를 스택에 넣고 방문 처리한다. <br>
최상단 노드의 인접노드들을 방문을 다했다면 스택에서 제거한다.
3. 2번의 방법을 수행할 수 없을때까지 반복한다.


# BFS
- Breath First Search의 약자로 `너비 우선 탐색`이라는 의미를 가진다.
- **가까운 노드부터 탐색하는 알고리즘**
- BFS 구현시 큐를 이용한다.
  - 인접한 노드를 반복적으로 큐에 넣도록 알고리즘을 작성한다면 자연스럽게 선입선출이 되어 가까운 노드부터 탐색하게 된다.
- 보통 DFS 보다 BFS 구현이 조금 더 빠르게 동작하고, `시간 복잡도는 O(N)`이 소요된다.

## BFS 동작 원리
1. 탐색 시작 노드를 큐에 넣고 방문 처리를 한다.
2. 큐에서 노드를 꺼내 해당 노드의 인접 노드 중에서 방문하지 않는 노드를 모두 큐에 삽입하고 방문 처리를 한다.
3. 2번의 과정을 더이상 수행할 수 없을 때 까지 반복한다.