# DFS
- Depth First Search 약자로 `깊이 우선 탐색`이라고 한다.
- 그래프에서 깊은 부분을 우선적으로 탐색한다는 뜻
- 그래프는 2가지 방법으로 표현할 수 있다.
- `시간 복잡도는 O(N)`이 소요된다.

1. 인접 행렬 : 2차원 배열로 그래프의 연결 관계를 표현
    - 노드가 연결된 형태를 기록한다.
    - 연결되지 않은 노드들끼리는 무한의 비용이 든다하여, 주로 무한으로 표현한다.
    - 무한은 논리적인 정답이 될 수 없기에 999999999와 같은 값으로 초기화한다.
    ```
              0
            /   \
          (7)   (5)
          /       \
         1         2
        가 있을때 인접 행렬은
      
        private static final int INFINITY = 999999999;
        final int[][] graph = {
            [0, 7, 5]
           ,[7, 0, INFINITY]
           ,[5, INFINITY, 0]
        };
      
        로 표현할 수 있다.
    ```
2. 인접 리스트 : 리스트로 그래프의 연결 관계를 표현
    - 인접 리스트 : 노드에 연결된 노드에 대한 정보를 차례대로 연결하며, 주로 링크드 리스트를 이용한다.
    ```
          0
        /   \
      (7)   (5)
      /       \
     1         2
    가 있을때 인접 리스트는
  
    0 -> 1 -> 2
    1 -> 0
    2 -> 0
   
    graph.add(new Node(1,7)) // (노드, 거리) 
    ```
## 인접 행렬과 인접 리스트의 차이
- 메모리 측면에서 탐색시 인접 행렬은 모든 관계를 저장한 상태에서 다뤄야하므로 노드의 갯수가 많을수록 메모리의 낭비가 있지만 <br>
인접 리스트는 연결된 정보만 가지고 탐색하기때문에 인접 행렬이 리스트보다 메모리 효율이 좋다.
- 속도 측면에서 인접 리스트는 연결된 데이터를 하나씩 확인해야해서 느리다.
- 그러므로 특정한 노드가 연결된 인접 노드를 순회해야하는 경우는 인접리스트 방식이 인접 행렬보다 메모리 낭비가 적다.


## DFS 동작 원리
- 특정한 경로로 탐색하다가 특정한 상황에서 최대한 깊숙히 들어가서 노드를 방문 후 다시 돌아와 다른 경로로 탐색하는 과정을 거친다.
- 한번 방문했던 노드는 다신 방문하지 않기 위해 스택을 주로 이용한다.
1. 탐색 시작 노드를 Stack에 삽입 후 방문 처리를 한다.
2. 스택 최상단의 노드기준으로 방문하지 않은 노드가 있다면 최상단 노드의 인접 노드를 스택에 넣고 방문 처리한다. <br>
최상단 노드의 인접노드들을 방문을 다했다면 스택에서 제거한다.
3. 2번의 방법을 수행할 수 없을때까지 반복한다.

